<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>graveyard's Multi-Option Prediction Overlay</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Francois+One&display=swap" rel="stylesheet">
<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="animation.css">
<link rel="icon" type="image/x-icon" href="favicon.ico">
<style>
	#centercontentbox {
		background-color: #09131CCC;
		border-radius: 11px 11px 26px 11px;
		margin-top: 7px;
		padding: 35px;
		padding-top: 13px;
		backdrop-filter: blur(10px);
		height: 600px;
		width: 360px;
		position: fixed;
  		top: 50%;
    	left: 50%;
    	transform: translate(-50%, -50%);
    	text-align: center;
		overflow: hidden;
		}
        #log {
			margin-top: 20px;
            box-sizing: border-box;
            overflow: auto;
            border: none;
        }

        #log span {
            margin-right: 5px;
        }
		.confetti-wrapper {
		 position: fixed;
			top: 0;
			margin-top: -25%;
		  width: 90%;
		  height: 100%;
		  pointer-events: none; /* Prevent interaction */
		  overflow: hidden;
		  z-index: 100;
		  padding-top: -50%;	  
		  object-fit: cover;
		}
		
		.confetti-piece {
		  position: absolute;
		  width: 12px;
		  height: 19px;
		  top: 0;
		  background: var(--confetti-color);
		  opacity: 0.9;
		  animation: confetti-fall var(--fall-duration, 3s) linear;
		  z-index: 100;
		  transition: background 1s ease-in;
		}
		/* Randomize confetti properties */
		.confetti-piece:nth-child(1) {
		  left: 10%;
		  --confetti-color: #ed0677;
		  --fall-duration: 3s;
		}
		.confetti-piece:nth-child(2) {
		  left: 25%;
		  --confetti-color: #871668;
		  --fall-duration: 4s;
		}
		.confetti-piece:nth-child(3) {
		  left: 40%;
		  --confetti-color: #92278f;
		  --fall-duration: 3.5s;
		}
		.confetti-piece:nth-child(4) {
		  left: 60%;
		  --confetti-color: #d80b8c;
		  --fall-duration: 2.5s;
		}
		.confetti-piece:nth-child(5) {
		  left: 80%;
		  --confetti-color: #812990;
		  --fall-duration: 2s;
		}
		.confetti-piece {
		  clip-path: polygon(50% 30%, 0% 80%, 100% 100%);
		}
		@keyframes confetti-fall {
		  0% {
			transform: translateY(0) rotate(0deg);
			opacity: 0;
		  }
		  3% {
			opacity: 100;
		  }
		  74% {
			opacity: 0;
		  }
		  100% {
			transform: translateY(50vh) rotate(760deg);
			opacity: 0;
		  }
		}
		#bigcontainer1 {
		  width: 100%;
		  height: 100%;
		  text-align: center;
		  }
	  #bigcontainer {
	  background-image: url('bg.png');
		text-align: center;
		min-height: 100vh;
		height: auto;
		background-size: cover;
		background-position: center;
	  display: flex;
	  }
    </style>
</head>
<body onClick="bullshit();">
<div id="bigcontainer1"><div id="bigcontainer">
				
			<div id="centercontentbox">

				<img id="gy-logo" style="float:left; margin-left:-15px;" src="gxpreds.png">
                    <span class="description-name text"><a class="logofollow-box" href="https://www.twitch.tv/graveyard420woo" target="_blank"><img id="gy-logo" src="gy.png"></a>Description:</span>
                    <span class="description-main description">This is an overlay tool that shows a dynamic display for multi-option Twitch channel points predictions!<br>
It will automatically receive any prediction's outcomes and betting activity in an animated overlay whenever you activate a new prediction on your stream.<br>
Simply add it as a browser source by copying the URL of the blank screen after connecting your Twitch!</span>
<br>
                    <a id="authorize" class="login-box" target="">
                     <img id="twitch-logo" src="tlogo.png">
                        <span id="twitch-text">Connect Your Twitch!</span>
                    </a>
                    
                    <a class="follow-box" href="https://www.twitch.tv/graveyard420woo" target="_blank">
                     <img id="twitch-logo" src="tlogo.png">
                        <span id="gy-text">Follow graveyard's channel!</span>
                    </a>
                    
                    <span class="description"><br>If this tool helps you along your journey, I am so pleased! I do indie dev work like this to help the universe and everyone in it. It's tough out there, you deserve a simple solution to this.. Feel free to drop a follow on my channel with the above link! </span>
                    
                    <a class="paypal-box" href="https://www.paypal.com/ncp/payment/G7TJ4WR438AJU" target="_blank">
                     <img id="twitch-logo" src="pp.png">
                        <span id="paypal-text">Donate/Tip with Paypal!</span>
                    </a>
                    
                    <span class="description"><br>Just your humble artist/tech (; Always appreciated but never necessary or solicited.</span>
                
                <div>
                    <div id="log">
                        <div>Click "Connect Your Twitch" above to start!</div>
                    </div> 
<span id="keepalive"></span>
                </div>
            </div>

    <script type="text/javascript" src="eventsub.js"></script>
    <script type="text/javascript">
		
        var client_id = 'nou4egds05d6svv8tf4aycwqijw0iz';
        var redirect = 'https://graveyard420woo.github.io/GXPreds/';
        var access_token = '';
        var socket_space = '';
        var session_id = '';
        var my_user_id = '';
		var predID = '';
		var redeemUserColor = '';
		var barColorUser = '';
		var numberOfActiveElements = 0;
		var newMaxWidth = 0;
		var	newWidthPercentage = 0;
		var globalWidth = 0;
		var percentCheck = 0;
		var cLoseTime = 0;
		var totalPredictors = 0;
		var zeroCheck = 0;
		let barDataQueue = [];
								
		document.getElementById('authorize').setAttribute('href', 'https://id.twitch.tv/oauth2/authorize?client_id=' + client_id + '&redirect_uri=' + encodeURIComponent(redirect) + '&response_type=token&scope=channel:manage:predictions');

        if (document.location.hash && document.location.hash != '') {
            log('Checking for token');
            var parsedHash = new URLSearchParams(window.location.hash.slice(1));
            if (parsedHash.get('access_token')) {
                log('Got a token');
                processToken(parsedHash.get('access_token'));
            }
        }
		
		function getUrlParameter(name) {
		  const urlParams = new URLSearchParams(window.location.search);
		  return urlParams.get(name);
		}
		
		function playTheStartSound(){
		var startaudio = new Audio('start.mp3');
		startaudio.play();
		startaudio.volume = .7;
		}
		function playTheLockedSound(){
		var lockedaudio = new Audio('locked.mp3');
		lockedaudio.play();
		lockedaudio.volume = .7;
		}
		function playTheEndedSound(){
		var endedaudio = new Audio('ended.mp3');
		endedaudio.play();
		endedaudio.volume = .7;
		}
		
		function clearOldElements(){
			const elementsToRemove1 = document.querySelectorAll('div[id^="outcomebar"]'); // Selects divs with IDs starting with "prefix_"
			elementsToRemove1.forEach(element => {
				element.style.transition = 'none';
				element.style.opacity = '0%';
				element.style.transition = 'all 1s ease-in-out';
   			 element.remove();
			});	
			const elementsToRemove2 = document.querySelectorAll('div[id^="outcomename"]'); // Selects divs with IDs starting with "prefix_"
			elementsToRemove2.forEach(element => {
				element.style.transition = 'none';
				element.style.opacity = '0%';
				element.style.transition = 'all 1s ease-in-out';
   			 element.remove();
			});
			const elementsToRemove4 = document.querySelectorAll('div[id^="winningdiv"]'); // Selects divs with IDs starting with "prefix_"
			elementsToRemove4.forEach(element => {
				element.style.transition = 'none';
				element.style.opacity = '0%';
				element.style.transition = 'all 1s ease-in-out';
   			 element.remove();
			});
			const elementsToRemove5 = document.querySelectorAll('div[id^="losingdiv"]'); // Selects divs with IDs starting with "prefix_"
			elementsToRemove5.forEach(element => {
				element.style.transition = 'none';
				element.style.opacity = '0%';
				element.style.transition = 'all 1s ease-in-out';
   			 element.remove();
			});
			const elementsToRemove3 = document.querySelectorAll('div[class^="confetti-piece"]'); // Selects divs with classes starting with "prefix_"
			elementsToRemove3.forEach(element => {
   			 element.remove();
			});
			const elementsToRemove6 = document.querySelectorAll('div[id^="timerdiv"]'); // Selects divs with IDs starting with "prefix_"
			elementsToRemove6.forEach(element => {
   			element.style.opacity = '0%';
			element.remove();
			if (typeof intervalForTimer !== 'undefined') {
				clearInterval(intervalForTimer);
			}
			});	
			document.getElementById('animation').style.opacity = "0%";
			document.getElementById('animation').style.top = "250";
		}
		
		function dimTheBars(){
			const elementsToDim1 = document.querySelectorAll('div[id^="outcomebar"]'); // Selects divs with IDs starting with "prefix_"
			elementsToDim1.forEach(element => {
   			 element.style.opacity = "69%"
			});	
			const elementsToDim2 = document.querySelectorAll('div[id^="outcomename"]'); // Selects divs with IDs starting with "prefix_"
			elementsToDim2.forEach(element => {
   			 element.style.opacity = "69%"
			});
		}
		
		function fadeoutTheBars(){
			const elementsToFade1 = document.querySelectorAll('div[id^="outcomebar"]'); // Selects divs with IDs starting with "prefix_"
			elementsToFade1.forEach(element => {
   			 element.style.opacity = "0%"
			});	
			const elementsToFade2 = document.querySelectorAll('div[id^="outcomename"]'); // Selects divs with IDs starting with "prefix_"
			elementsToFade2.forEach(element => {
   			 element.style.opacity = "0%"
			});
			const elementsToFade3 = document.querySelectorAll('div[id^="timerdiv"]'); // Selects divs with IDs starting with "prefix_"
			elementsToFade3.forEach(element => {
   			 element.style.opacity = "0%"
			 element.style.transform = 'scale(0.5) rotate(9deg)';
			});
		}
		
		function fadeinEverything(){
			const elementsToFadein1 = document.querySelectorAll('div[id^="outcomebar"]'); // Selects divs with IDs starting with "prefix_"
			elementsToFadein1.forEach(element => {
   			 element.style.opacity = "90%"
			});	
			const elementsToFadein2 = document.querySelectorAll('div[id^="outcomename"]'); // Selects divs with IDs starting with "prefix_"
			elementsToFadein2.forEach(element => {
   			 element.style.opacity = "100%"
			});
			document.getElementById('animation').style.opacity = "100%";
			document.getElementById('animation').style.top = "150";
		}
		
		function showTheTimer(seconds, startTimeUTC){
			const utcTimeString = startTimeUTC;
			const utcDate = new Date(utcTimeString); 
			const nowUTC = Date.now(); // Get current UTC time in milliseconds
			const utcTimeMilliseconds = utcDate.getTime(); 
			const elapsedTimeMilliseconds = nowUTC - utcTimeMilliseconds; // Calculate elapsed time in milliseconds
			const elapsedTimeSeconds = Math.floor(elapsedTimeMilliseconds / 1000);
			seconds = (seconds - elapsedTimeSeconds) - 57;
			//console.log(nowUTC);
			const container = document.getElementById('animation');
			const newTimerDiv = document.createElement('div');
			newTimerDiv.setAttribute('id', 'timerdiv');
			container.appendChild(newTimerDiv);
			let remainingSeconds = seconds;
			newTimerDiv.style.opacity = "0%";
			newTimerDiv.style.transform = 'scale(3) rotate(-48deg)';
			intervalForTimer = window.setInterval(() => {
				const minutes = Math.floor(remainingSeconds / 60);
				const seconds = remainingSeconds % 60;
			
				newTimerDiv.innerHTML = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
	
				newTimerDiv.style.opacity = "69%";
				newTimerDiv.style.transform = 'scale(1) rotate(-9deg)';
			
				if (remainingSeconds <= 0) {
				  clearInterval(intervalForTimer);
				  newTimerDiv.style.opacity = "0%";
				  newTimerDiv.style.transform = 'scale(0.5) rotate(9deg)';
				}
				remainingSeconds--;
			  }, 1000);			
		}
		
		function playTheLockedAnimation(){
			
			if (typeof timerL3 !== 'undefined') {
				clearTimeout(timerL3);
			}
			if (typeof timerR3 !== 'undefined') {
				clearTimeout(timerR3);
			}
			if (typeof timerP3 !== 'undefined') {
				clearTimeout(timerP3);
			}
			if (typeof timerP4 !== 'undefined') {
				clearTimeout(timerP4);
			}
			if (typeof intervalForTimer !== 'undefined') {
				clearInterval(intervalForTimer);
			}
			
			const container = document.getElementById('animation');
			const newLockedDiv = document.createElement('div'); // make a new div
			newLockedDiv.setAttribute('id', 'lockeddiv'); // give it an id
			newLockedDiv.textContent = 'LOCKED!'; // add some text
			container.appendChild(newLockedDiv); // add it to the page
			playTheLockedSound();
			const fadetimersout = document.querySelectorAll('div[id^="timerdiv"]'); // Selects divs with IDs starting with "prefix_"
				fadetimersout.forEach(element => {
				 element.style.opacity = "0%"
				 element.style.transform = 'scale(0.5) rotate(9deg)';
				});
			timerL0=window.setTimeout(
				function(){
					newLockedDiv.style.opacity = '100%';
					newLockedDiv.style.transform = 'scale(1.2) rotate(-23deg)';
					dimTheBars();
				},150);
			timerL1=window.setTimeout(
				function(){
					newLockedDiv.style.opacity = '0%';
					newLockedDiv.style.transform = 'scale(1) rotate(-18deg)';
				},8000);
			timerL2=window.setTimeout(
				function(){
					newLockedDiv.remove();
				},8500); 
			timerL3=window.setTimeout(
				function(){
					fadeoutTheBars();
				},45000); 
			}
			
		function playTheEndedAnimation(paidstatus, pred_id){
			if (typeof timerL3 !== 'undefined') {
				clearTimeout(timerL3);
			}
			if (typeof timerR3 !== 'undefined') {
				clearTimeout(timerR3);
			}
			if (typeof timerP3 !== 'undefined') {
				clearTimeout(timerP3);
			}
			if (typeof timerP4 !== 'undefined') {
				clearTimeout(timerP4);
			}
			if (typeof intervalForTimer !== 'undefined') {
				clearInterval(intervalForTimer);
			}
			
			fadeinEverything();
						
			if(paidstatus == 'canceled'){
				
				const container = document.getElementById('animation');
				const newRefundedDiv = document.createElement('div');
				newRefundedDiv.setAttribute('id', 'refundeddiv');
				newRefundedDiv.textContent = 'REFUNDED!';
				container.appendChild(newRefundedDiv);
				playTheEndedSound();
				const fadetimersout = document.querySelectorAll('div[id^="timerdiv"]'); // Selects divs with IDs starting with "prefix_"
					fadetimersout.forEach(element => {
					 element.style.opacity = "0%"
					 element.style.transform = 'scale(0.5) rotate(9deg)';
					});
				timerR0=window.setTimeout(
					function(){
						newRefundedDiv.style.opacity = '100%';
						newRefundedDiv.style.transform = 'scale(1.2) rotate(-23deg)';
					},150);
				timerR1=window.setTimeout(
					function(){
						newRefundedDiv.style.opacity = '0%';
						newRefundedDiv.style.transform = 'scale(1) rotate(-18deg)';
					},4000);
				timerR2=window.setTimeout(
					function(){
						newRefundedDiv.remove();
					},4500); 
				timerR3=window.setTimeout(
					function(){
						fadeoutTheBars();
						container.style.opacity = '0%';
					},9500);
				}
						
			else if(paidstatus == 'resolved'){
				
				doPredEndStuff(my_user_id, pred_id);
				
				const container = document.getElementById('animation');
				const newPaidDiv = document.createElement('div');
				newPaidDiv.setAttribute('id', 'paiddiv');
				newPaidDiv.textContent = 'PAID!';
				container.appendChild(newPaidDiv);
				playTheEndedSound();
				timerP0=window.setTimeout(
					function(){
						newPaidDiv.style.opacity = '100%';
						newPaidDiv.style.transform = 'scale(2) rotate(-23deg)';
					},150);
				timerP1=window.setTimeout(
					function(){
						newPaidDiv.style.opacity = '0%';
						newPaidDiv.style.transform = 'scale(1) rotate(-18deg)';
					},4000);			
				timerP2=window.setTimeout(
					function(){
						newPaidDiv.remove();
					},4500); 
				timerP3=window.setTimeout(
					function(){
						dimTheBars();
					},35500);
				timerP4=window.setTimeout(
					function(){
						fadeoutTheBars();
						container.style.opacity = '0%';
					},77000);
				}
			}

        function log(message) {
            let p = document.createElement('div');
            document.getElementById('log').prepend(p);

            let tim = document.createElement('span');
            let t = [
                new Date().getHours(),
                new Date().getMinutes(),
                new Date().getSeconds()
            ]
            t.forEach((v, i) => {
                t[i] = v < 10 ? '0' + v : v;
            });
            tim.textContent = t.join(':');
            p.append(tim);

            let l = document.createElement('span');
            p.append(l);
            l.textContent = message;
        }

        function processToken(token) {
            access_token = token;

            fetch(
                'https://api.twitch.tv/helix/users',
                {
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token
                    }
                }
            )
                .then(resp => resp.json())
                .then(resp => {
                    socket_space = new initSocket(true);
                    socket_space.on('connected', (id) => {
                        log(`Connected to WebSocket with ${id}`);
                        session_id = id;
                        my_user_id = resp.data[0].id;
                        requestHooks(resp.data[0].id, my_user_id);	
						getPredStuffFirstRun(my_user_id);							
                    });
                    socket_space.on('session_keepalive', () => {
                        document.getElementById('keepalive').textContent = new Date();
                    });
					socket_space.on('channel.prediction.begin', ({ metadata, payload }) => {
    					let { event } = payload;
    					let { id , title } = event;
    					
						console.log(`${title} Prediction has started! its ID is ${id}`);
						log(`${title} Prediction has started! its ID is ${id}`);
						
						clearOldElements();
						
						setTimeout(() => {
							getPredStuff(my_user_id, `${id}`)
						}, 200); // A small delay										
					});
					socket_space.on('channel.prediction.progress', ({ metadata, payload }) => {
    					let { event } = payload;
    					let { id , title, status } = event;
										
						predProgressStuff(my_user_id, `${id}`)
    					
						console.log(`${title} Prediction has progressed! ${id}`);
						log(`${title} Prediction has progressed! ${id}`);										
					});
					socket_space.on('channel.prediction.lock', ({ metadata, payload }) => {
    					let { event } = payload;
    					let { id , title } = event;
    					
						console.log(`${title} Prediction has locked! ${id}`);
						log(`${title} Prediction has locked! ${id}`);	
						
						playTheLockedAnimation();							
					});
					socket_space.on('channel.prediction.end', ({ metadata, payload }) => {
    					let { event } = payload;
    					let { id , title, status } = event;
    					
						console.log(`${title} Prediction has ended! ${id} ${status}`);
						log(`${title} Prediction has ended! ${id}`);
						
						playTheEndedAnimation(`${status}`, `${id}`);										
					});
				})	
                .catch(err => {
                    console.log(err);
                    log('Error with Users Call');
                });
        }

		function getPredStuffFirstRun(broadcaster_id) {
            let url = new URL('https://api.twitch.tv/helix/predictions?broadcaster_id='+broadcaster_id);
            fetch(
                url,
                {
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token
                    }
                }
            )
                .then(resp => resp.json())
                .then(resp => {
					//console.dir(resp.data[0]);
					
					if (resp.data[0].status == "ACTIVE"){
						
					//log(`Got ${resp.data[0].outcomes.length} outcomes`);
					if(resp.data[0].outcomes.length == 2){ // check if its a two option pred, if so don't start anything
					} else {
					
					if (typeof timerL3 !== 'undefined') {
						clearTimeout(timerL3);
					}
					if (typeof timerR3 !== 'undefined') {
						clearTimeout(timerR3);
					}
					if (typeof timerP3 !== 'undefined') {
						clearTimeout(timerP3);
					}
					if (typeof timerP4 !== 'undefined') {
						clearTimeout(timerP4);
					}
					if (typeof intervalForTimer !== 'undefined') {
						clearInterval(intervalForTimer);
					}
					
					// confetti start
					document.getElementById("confettianimation").style.display = "block";
					document.getElementById("confettianimation").style.opacity = "80";
					const confettiWrapper = document.querySelector('.confetti-wrapper');
					for (let i = 0; i < 50; i++) {
					  const confetti = document.createElement('div');
					  confetti.classList.add('confetti-piece');
					  confetti.style.left = `${Math.random() * 100}%`;
					  confetti.style.top = '30%';
					  confetti.style.display = 'block';
					  confetti.style.setProperty('--fall-duration', `${Math.random() * 2 + 4}s`);
					  confettiWrapper.appendChild(confetti);
					}
					timer3a=window.setTimeout(
						function(){
							document.getElementById("confettianimation").style.display = "none";
						},3900);
					// confetti end
					
					const container = document.getElementById('animation');
					const numberOfDivs = `${resp.data[0].outcomes.length}`
										
					  for (let i = 0; i < numberOfDivs; i++) {

						const newDiv2 = document.createElement('div');
						newDiv2.textContent = resp.data[0].outcomes[i].title;
						newDiv2.classList.add('outcomebar-' + i);
						newDiv2.setAttribute('id', 'outcomebar');
						container.appendChild(newDiv2);
						newDiv2.style.width = newDiv2.offsetWidth;
						
						const newDiv4 = document.createElement('div');
						newDiv4.classList.add('outcomecp-' + i);
						newDiv2.appendChild(newDiv4);
					  }
					  
					  const globalWidthHolder = document.getElementById('animation');
					  globalWidth = globalWidthHolder.offsetWidth;
					  console.log('globalwidth is:'+globalWidth);
					  
					  setTimeout(() => {
					   globalWidth = globalWidthHolder.offsetWidth;
					   console.log('globalwidth is:'+globalWidth);				
					  for (let i = 0; i < numberOfDivs; i++) {
						changeDivWidthByClass('outcomebar-' + i, 0, numberOfDivs, i);
					  }
					}, 800); // A small delay
					showTheTimer(resp.data[0].prediction_window, resp.data[0].created_at);
					fadeinEverything();
					playTheStartSound();
					totalPredictors = 0;
					
					setTimeout(() => {
						predProgressStuff(my_user_id, `${resp.data[0].id}`)
					}, 1800); // A small delay
				   }
				  }
                })
                .catch(err => {
                    console.log(err);
                    log('Error with Users Call');
                });
        }
		
		function getPredStuff(broadcaster_id, pred_id) {
            let url = new URL('https://api.twitch.tv/helix/predictions?broadcaster_id='+broadcaster_id+'&id='+pred_id);
            fetch(
                url,
                {
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token
                    }
                }
            )
                .then(resp => resp.json())
                .then(resp => {
					//console.dir(resp.data[0]);
					//log(`Got ${resp.data[0].outcomes.length} outcomes`);
					if(resp.data[0].outcomes.length == 2){ // check if its a two option pred, if so don't start anything
					} else {
					
					if (typeof timerL3 !== 'undefined') {
						clearTimeout(timerL3);
					}
					if (typeof timerR3 !== 'undefined') {
						clearTimeout(timerR3);
					}
					if (typeof timerP3 !== 'undefined') {
						clearTimeout(timerP3);
					}
					if (typeof timerP4 !== 'undefined') {
						clearTimeout(timerP4);
					}
					if (typeof intervalForTimer !== 'undefined') {
						clearInterval(intervalForTimer);
					}
							
					// confetti start
					document.getElementById("confettianimation").style.display = "block";
					document.getElementById("confettianimation").style.opacity = "80";
					const confettiWrapper = document.querySelector('.confetti-wrapper');
					for (let i = 0; i < 50; i++) {
					  const confetti = document.createElement('div');
					  confetti.classList.add('confetti-piece');
					  confetti.style.left = `${Math.random() * 100}%`;
					  confetti.style.top = '30%';
					  confetti.style.display = 'block';
					  confetti.style.setProperty('--fall-duration', `${Math.random() * 2 + 4}s`);
					  confettiWrapper.appendChild(confetti);
					}
					timer3a=window.setTimeout(
						function(){
							document.getElementById("confettianimation").style.display = "none";
						},3900);
					// confetti end
					
					const container = document.getElementById('animation');
					const numberOfDivs = `${resp.data[0].outcomes.length}`
										
					  for (let i = 0; i < numberOfDivs; i++) {

						const newDiv2 = document.createElement('div');
						newDiv2.textContent = resp.data[0].outcomes[i].title;
						newDiv2.classList.add('outcomebar-' + i);
						newDiv2.setAttribute('id', 'outcomebar');
						container.appendChild(newDiv2);
						newDiv2.style.width = newDiv2.offsetWidth;
						
						const newDiv4 = document.createElement('div');
						newDiv4.classList.add('outcomecp-' + i);
						newDiv2.appendChild(newDiv4);
					  }
					  
					  const globalWidthHolder = document.getElementById('animation');
					  globalWidth = globalWidthHolder.offsetWidth;
					  
					setTimeout(() => {
					   globalWidth = globalWidthHolder.offsetWidth;
					   console.log('globalwidth is:'+globalWidth);				
					  for (let i = 0; i < numberOfDivs; i++) {
						changeDivWidthByClass('outcomebar-' + i, 0, numberOfDivs, i);
					  }
					}, 800);  
					showTheTimer(resp.data[0].prediction_window, resp.data[0].created_at);
					fadeinEverything();
					playTheStartSound();
					totalPredictors = 0;
				   }
                })
                .catch(err => {
                    console.log(err);
                    log('Error with Users Call');
                });
        }
		
		function predProgressStuff(broadcaster_id, pred_id) {
            let url = new URL('https://api.twitch.tv/helix/predictions?broadcaster_id='+broadcaster_id+'&id='+pred_id);
            fetch(
                url,
                {
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token
                    }
                }
            )
                .then(resp => resp.json())
                .then(resp => {
					//console.dir(resp.data[0]);					
					const numberOfDivs = `${resp.data[0].outcomes.length}`
					const outcomeCPValues = [];
					
					  for (let i = 0; i < numberOfDivs; i++) {
						  
						  outcomeCPValues.push(`${resp.data[0].outcomes[i].channel_points}`);
						  												  
						//changeDivWidthByClass('outcomebar-' + i, `${resp.data[0].outcomes[i].channel_points}`, numberOfDivs, i);
						countUpToCPointsNumber('outcomecp-' + i, `${resp.data[0].outcomes[i].channel_points}`, `${resp.data[0].outcomes[i].title}`);
						
						if (`${resp.data[0].outcomes[i].users}` == 0) { 
						
							//log(`no betters on ` + i);
						
						} else {
																				
							barColorUser = `${resp.data[0].outcomes[i].top_predictors[0].user_id}`	
							doChatUsersBarColor(barColorUser, 'outcomebar-' + i)
						}
						
						if (i == numberOfDivs){
							 for (let i = 0; i < numberOfDivs; i++) {
								const barProcessor = createBarProcessor(
								  'outcomebar-' + i,      // The class name of your bars
								  outcomeCPValues.length,   // The total number of bars we expect
								  globalWidth       // The container width in pixels
								);
								
							  outcomeCPValues.forEach(value => {
								  barProcessor(value);
								});	
							 }
						}
					  }					
                })
                .catch(err => {
                    console.log(err);
                    log('Error with Users Call');
                });
        }
		
		function bullshit() {
            					
					const numberOfDivs = `5`
					const outcomeCPValues = [];
					
					  for (let i = 0; i < numberOfDivs; i++) {
						  
						  outcomeCPValues.push(`1000*i`);
						  												  
						countUpToCPointsNumber('outcomecp-' + i, `1000*i`, `xyzz`);
												
							//barColorUser = `gr4vebot`	
							//doChatUsersBarColor(barColorUser, 'outcomebar-' + i)
						
						if (i == numberOfDivs-1){
							 for (let i = 0; i < numberOfDivs; i++) {
								const barProcessor = createBarProcessor(
								  'outcomebar-' + i,      // The class name of your bars
								  outcomeCPValues.length,   // The total number of bars we expect
								  globalWidth       // The container width in pixels
								);
								
							  outcomeCPValues.forEach(value => {
								  barProcessor(value);
								});	
							 }
						}
					  }					
        }
		
		function countUpToCPointsNumber(className, stones, title){
		
			const counterElement = document.querySelector('.'+className);
			const targetNumber = stones; // The number you want to count up to
			const duration = 1000; // Duration of the animation in milliseconds (1 second)
			const interval = 10; // Interval for updating the counter (in milliseconds)
			const increment = targetNumber / (duration / interval); // Calculate the increment per interval
			
			let cptextContent = counterElement.textContent; // textContent will be ""
			let cpnumericValue = parseFloat(cptextContent); // numericValue will be NaN
			if (isNaN(cpnumericValue)) {
			  cpnumericValue = 0; // numericValue will be 0
			}
		
			let currentNumber = cpnumericValue;
						
			const timerCP = setInterval(() => {
				currentNumber += increment;
				if (currentNumber >= targetNumber) {
					currentNumber = targetNumber; // Ensure the counter doesn't exceed the target
					clearInterval(timerCP); // Stop the timer when the target is reached
				}
				if (Math.round(currentNumber) == 0){
				}else {
					counterElement.textContent = Math.round(currentNumber); // Update the displayed number, rounded to the nearest integer
				}
			}, interval);	
		}
		
		/**
		 * Creates and returns a new bar processing function with its own private state.
		 * This prevents race conditions from overlapping API calls.
		 *
		 * @param {string} className - The class name of the bar elements.
		 * @param {number} totalBars - The TOTAL number of bars expected in this batch.
		 * @param {number} globalWidth - The maximum possible width in pixels.
		 * @returns {Function} A new processor function to be called for each data point.
		 */
		function createBarProcessor(className, totalBars, globalXWidth) {
		  // --- Private State ---
		  // This data is protected within the closure. Each call to the factory
		  // creates a NEW queue and counter.
		  let dataQueue = [];
		  let callCount = 0;
		  // ---
		
		  // The factory returns this function
		  return function processSingleBar(value) {
			callCount++;
			dataQueue.push(value);
			console.log('pushed value');
		
			// Is this the last piece of data we were expecting for THIS batch?
			if (callCount === totalBars) {
			  // This block only runs once when the batch is complete.
			  const elements = document.getElementsByClassName(className);
			  const maxValueInData = Math.max(...dataQueue);
		
			  if (elements.length !== totalBars) {
				console.error("Mismatch: Number of DOM elements does not match expected number of bars.");
				return; // Exit to prevent errors
			  }
		
			  for (let i = 0; i < elements.length; i++) {
				const initialWidth = elements[i].offsetWidth;
				const currentValue = dataQueue[i];
				let calculatedPixelWidth = 0;
		
				if (maxValueInData > 0) {
				  calculatedPixelWidth = (currentValue / maxValueInData) * globalXWidth;
				}
		
				const finalPixelWidth = Math.max(calculatedPixelWidth, initialWidth);
				elements[i].style.width = `${finalPixelWidth}px`;
				console.log('done the width');
			  }
			  // No need to reset the queue, because this entire function and its
			  // state will be discarded after it's done.
			}
		  };
		}
				
		function changeDivWidthByClass(className, newWidth, numberOfDivs, currentDiv) {
			
			 // 1. Add the value for the current bar to our queue.
			  barDataQueue.push(newWidth);
			
			  // 2. Check if this is the LAST bar in the set.
			  if (currentDiv === numberOfDivs - 1) {
				
				const elements = document.getElementsByClassName(className);
				const maxValueInData = Math.max(...barDataQueue);
			
				// 3. Loop through the elements and set their final width.
				for (let i = 0; i < elements.length; i++) {
				  // --- NEW: Get the bar's initial width directly from the DOM ---
				  // .offsetWidth is perfect here as it returns the rendered width in pixels as a number.
				  const initialWidth = elements[i].offsetWidth;
			
				  const currentValue = barDataQueue[i];
				  let calculatedPixelWidth = 0;
			
				  if (maxValueInData > 0) {
					calculatedPixelWidth = (currentValue / maxValueInData) * globalWidth;
				  }
				  
				  // --- NEW: Compare the calculated width with the initial width ---
				  // Math.max() will return the larger of the two values.
				  // This ensures the bar's width will either grow or stay the same, but never shrink.
				  const finalPixelWidth = Math.max(calculatedPixelWidth, initialWidth);
				  
				  // 4. Apply the final, validated width to the element.
				  elements[i].style.width = `${finalPixelWidth}px`;
				}
			
				// 5. IMPORTANT: Reset the queue for the next API call.
				barDataQueue = [];
			  }
		}
		
		function changeDivColorByClassUser(className, newBgColor) {
		  const elements = document.getElementsByClassName(className);
		  for (let i = 0; i < elements.length; i++) {
			elements[i].style.backgroundColor = newBgColor;
		  }
		}
		
		function doChatUsersBarColor(theuserid, thedivclass) {
            let url = new URL('https://api.twitch.tv/helix/chat/color?user_id='+`${theuserid}`);
			//log('https://api.twitch.tv/helix/chat/color?user_id='+`${theuserid}`);
            fetch(
                url,
                {
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token
                    }
                }
            )
                .then(resp => resp.json())
                .then(resp => {
                    //log(`Got color: ${resp.data[0].color} for ${theuserid}`);
					//log(`class is for ${thedivclass}`);
					redeemUserColor = `${resp.data[0].color}`					
					if (resp.data[0].color) {
						changeDivColorByClassUser(thedivclass, redeemUserColor);
					} else {
						changeDivColorByClassUser(thedivclass, '#ED0080');	
					}
                })
                .catch(err => {
                    console.log(err);
                    log('Error with getUsersColor Call');
                });
        }
				
		function doPredEndStuff(broadcaster_id, pred_id) {
            let url = new URL('https://api.twitch.tv/helix/predictions?broadcaster_id='+broadcaster_id+'&id='+pred_id);
            fetch(
                url,
                {
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token
                    }
                }
            )
                .then(resp => resp.json())
                .then(resp => {
					//console.dir(resp.data[0]);
					//log(`Got winning outcome ID: ${resp.data[0].winning_outcome_id}`);
										
					const numberOfOutcomes = `${resp.data[0].outcomes.length}`
					cLoseTime = 0;
					
					  for (let i = 0; i < numberOfOutcomes; i++) {
						  
						  if (`${resp.data[0].winning_outcome_id}` == `${resp.data[0].outcomes[i].id}`){
								//console.log(`${resp.data[0].outcomes[i].title} is the winning outcome! `);  
								if (resp.data[0].outcomes[i].top_predictors){
									
								const container = document.getElementById('animation');
								const newWinningDiv = document.createElement('div');
								const ulElement = document.createElement("ul");

								newWinningDiv.setAttribute('id', 'winningdiv');
								ulElement.setAttribute('id', 'winlist');
								container.appendChild(newWinningDiv);
								newWinningDiv.appendChild(ulElement);
								
								const numberOfTopPredictors = `${resp.data[0].outcomes[i].top_predictors.length}`
								
								totalPredictors = totalPredictors + numberOfTopPredictors;
								
								for (let c = 0; c < numberOfTopPredictors; c++) {
								  const listItem = document.createElement("li"); // Create a new list item
								  listItem.innerHTML = `${resp.data[0].outcomes[i].top_predictors[c].user_name}` + '<span style="color:#03953F;"> + ' + `${resp.data[0].outcomes[i].top_predictors[c].channel_points_won}` + '</span>';
								  ulElement.appendChild(listItem); // Append the list item to the unordered list
  								 setTimeout(() => {
									  setTimeout(() => {
										  listItem.style.opacity = '100%'; 
										  listItem.style.marginTop = '58';
										}, 1000); // A small delay
									  setTimeout(() => {
										  listItem.style.transition = 'all .3s ease-in-out';
										  listItem.style.opacity = '0%'; 
										  listItem.style.marginTop = '22';
										}, 6000); // A small delay
									   }, (5000*c)+4000); 
								}
							}
								
						  } else {
							  	//console.log(`${resp.data[0].outcomes[i].title} didnt win `);
								changeDivColorByClassUser('outcomebar-' + i, 'rgba(204, 204, 204, 0.5)');
								
								if (resp.data[0].outcomes[i].top_predictors){
									
									const container = document.getElementById('animation');
									const newLosingDiv = document.createElement('div');
									const ulElement = document.createElement("ul");
	
									newLosingDiv.setAttribute('id', 'losingdiv');
									ulElement.setAttribute('id', 'loselist');
									container.appendChild(newLosingDiv);
									newLosingDiv.appendChild(ulElement);

									const numberOfTopPredictorsLose = `${resp.data[0].outcomes[i].top_predictors.length}`
									
									totalPredictors = totalPredictors + numberOfTopPredictorsLose;
									
									for (let c = 0; c < numberOfTopPredictorsLose; c++) {
									  const listItem = document.createElement("li"); // Create a new list item
									  listItem.innerHTML = `${resp.data[0].outcomes[i].top_predictors[c].user_name}` + '<span style="color:#ED1A3B;"> - ' + `${resp.data[0].outcomes[i].top_predictors[c].channel_points_used}` + '</span>';
									  ulElement.appendChild(listItem); // Append the list item to the unordered list
									  const cLoseTimeee = cLoseTime;
									  cLoseTime = cLoseTime + 1;
									  //console.log(cLoseTimeee);
									  setTimeout(() => {
										  setTimeout(() => {
											  listItem.style.opacity = '100%'; 
											  listItem.style.marginTop = '80';
											}, 1000); // A small delay
										  setTimeout(() => {
											  listItem.style.opacity = '0%'; 
											  listItem.style.marginTop = '180';
											}, 5000); // A small delay
										   }, 4000*cLoseTimeee); // A small delay
									}
								}
								
						  }
						  
					  }	
									
                })
                .catch(err => {
                    console.log(err);
                    log('Error with Users Call');
                });
        }
		

        function requestHooks(user_id, my_id) {
            let eventSubTypes = {
				  'channel.prediction.begin': { version: "1", condition: { broadcaster_user_id: user_id } },
				  'channel.prediction.progress': { version: "1", condition: { broadcaster_user_id: user_id } },
				  'channel.prediction.lock': { version: "1", condition: { broadcaster_user_id: user_id } },
				  'channel.prediction.end': { version: "1", condition: { broadcaster_user_id: user_id } },
            }	
            
            log(`Spawn Topics for ${user_id}`);

            for (let type in eventSubTypes) {
                log(`Attempt create ${type} - ${user_id}`);
                let { version, condition } = eventSubTypes[type];

                spawnHook(type, version, condition);
            }
        }
        function spawnHook(type, version, condition) {
            fetch(
                'https://api.twitch.tv/helix/eventsub/subscriptions',
                {
                    "method": "POST",
                    "headers": {
                        "Client-ID": client_id,
                        "Authorization": "Bearer " + access_token,
                        'Content-Type': 'application/json'
                    },
                    "body": JSON.stringify({
                        type,
                        version,
                        condition,
                        transport: {
                            method: "websocket",
                            session_id
                        }
                    })
                }
            )
                .then(resp => resp.json())
                .then(resp => {
                    if (resp.error) {
                        log(`Error with eventsub Call ${type} Call: ${resp.message ? resp.message : ''}`);
                    } else {
                        log(`Created ${type}`);
						//clear the scene for browser source use
						document.getElementById("bigcontainer").style.display = "none";
                    }
                })
                .catch(err => {
                    console.log(err);
                    log(`Error with eventsub Call ${type} Call: ${err.message ? err.message : ''}`);
                });
        }
    </script>
</div></div>
<div id="animation">
<div class="confetti-wrapper" id="confettianimation"></div>
</div></div></div> 
</body></html>